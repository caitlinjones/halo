removeExcludedPoints<-function(ds,aFile,doPlot=F) {

    ds=ds %>%
        mutate(X=(XMax+XMin)/2,Y=-(YMax+YMin)/2) %>%
        dplyr::select(Sample,SPOT,UUID,X,Y,Marker,Value)

    boundaries=readHaloAnnotations(aFile)
    regionTable=boundaries %>% bind_rows %>% count(RegionNum,RegionCode)
    excB=boundaries[regionTable$RegionCode!="Tum"]

    spCells=ds %>% dplyr::select(UUID,X,Y)
    coordinates(spCells)=~X+Y

    if(len(excB)>0){
        spExcB=seq(excB) %>% map(function(b){boundaryToSpatialPolygon(excB[[b]],b)})
        excludedCellIdx=NULL
        for(jj in len(spExcB)) {
            excCellJJ=unlist(over(spExcB[[jj]],geometry(spCells),returnList=T))
            excludedCellIdx=union(excludedCellIdx,excCellJJ)
        }
        #points(spCells[excludedCellIdx,],col=3,cex=.7)
        if(len(excludedCellIdx)>0)
            ds=ds[-excludedCellIdx,]
    }

    return(ds)

}

#' Remove exclusion boundaries that are contained in another one
#' 
#' Remove data from boundaries table that represent exclusion boundaries
#' that are completely surrounded by another exclusion boundary
#' 
#' @param boundaries            table generated by readHaloAnnotations
#'                             
removeContainedBoundaries <- function(boundaries){
 
    regionTable <- boundaries %>% bind_rows %>% count(RegionNum,RegionCode)
    excB <- boundaries[regionTable$RegionCode!="Tum"]
    tumB <- boundaries[regionTable$RegionCode=="Tum"]

    if(len(excB) > 1){
        ## make list of spatial polygons, one element for each exclusion boundary
        spExcB <- seq(excB) %>% map(function(b){boundaryToSpatialPolygon(excB[[b]],b)})

        ## are any contained within another?
        containedBoundary <- rep(FALSE,len(excB))
        for(i in seq(len(excB))){
            containedBoundary[i] <- spExcB[-i] %>% map(gContains,spExcB[[i]]) %>% unlist %>% any
        }
        ## remove those
        excB <- excB[!containedBoundary]
        #iiBnd <- which(regionTable$RegionCode!="Tum")[containedBoundary]
        #if(len(iiBnd)>0) {
        #    boundaries=boundaries[-iiBnd]
        #}
    }
    return(list(excB=excB,tumB=tumB))
}

#' Get counts of cells that fall within given distances of
#' tumor boundaries for a single FOV
#'
#' Given a set of interface bands, or set distances from a tumor 
#' boundary, count the numbers of cells that fall within those bands
#' 
#' @param  ds             a tibble containing data for one FOV, including columns
#'                        for X, Y, and one for each marker
#' @param bbData          a list containing X0,X1,Y0,Y1 representing the boundary
#'                        of the trimmed FOV
#' @param bbPlot          a list containing X0,X1,Y0,Y1 to be used as boundary of
#'                        entire plot
#' @param bbFOV0          a list containing X0,X1,Y0,Y1 showing the actual boundary
#'                        of the FOV (untrimmed)
#' @param aFile           Halo boundaries annotations file in XML format 
#' @param doPlot          logical indicating whether to plot cell type locations; 
#'                        default=TRUE
#' @param interfaceBands  vector of distances
getBandCounts<-function(ds,bbData,bbPlot,bbFOV0,aFile,doPlot=T,interfaceBands=NULL){

    flog.debug("getting boundaries")
    ## boundary XML data to table
    boundaries <- readHaloAnnotations(aFile)
    sepB <- removeContainedBoundaries(boundaries)
    tumB <- sepB$tumB
    excB <- sepB$excB
    if(is.null(tumB) || len(tumB) == 0){
        flog.info("No TUMOR boundaries found in file %s. Skipping.")
        return() 
    }

    if(is.null(interfaceBands)) {
        interfaceBands <- (-20:20)*10
    }

    markers <- ds %>% distinct(Marker) %$% as.character(Marker)

    flog.debug("getting midpoint of each cell")
    ## get midpoint of each cell
    ds <- ds %>%
          mutate(X=(XMax+XMin)/2,Y=-(YMax+YMin)/2) %>%
          dplyr::select(Sample,SPOT,UUID,X,Y,Marker,Value) %>%
          spread(Marker,Value)

    flog.debug("filtering out cells that fall outside bounding box")
    ## filter out cells that fall outside bounding box
    ds <- trimDFToBB(ds,bbData)

    ## add values for negative markers
    for(mi in markers) {
      ds[[paste0(mi,"-")]]=ifelse(ds[[mi]]==0,1,0)
    }

    ## create a SpatialPointsDataFrame
    spCells <- ds %>% dplyr::select(UUID,X,Y)
    coordinates(spCells) <- ~X+Y

    flog.debug("removing cells in exclusion boundaries")
    ## if there are still any exclusion boundaries, remove the cells that fall
    ## within those boundaries?
    if(len(excB)>0){
        spExcB <- seq(excB) %>% map(function(b){boundaryToSpatialPolygon(excB[[b]],b)})
        excludedCellIdx <- NULL
        for(jj in len(spExcB)) {
            excCellJJ <- unlist(over(spExcB[[jj]],geometry(spCells),returnList=T))
            excludedCellIdx <- union(excludedCellIdx,excCellJJ)
        }
        #points(spCells[excludedCellIdx,],col=3,cex=.7)
        if(len(excludedCellIdx)>0){
            ds <- ds[-excludedCellIdx,]
        }
    }

    flog.debug("updating spatialpointsdataframe")
    ## update the SpatialPointsDataFrame
    spCells <- ds %>% dplyr::select(UUID,X,Y)
    coordinates(spCells) <- ~X+Y

    flog.debug("getting tumor contour")
    ## filter data for cells that are near a tumor boundary AND inside
    ## the bounding box 
    tumorContour <- tumB %>% map(trimBoundaryToBB,bbData)
    flog.debug("merging X and Y")
    ## get x and y coords of all remaining tumor cells
    tumorBoundariesMergeXY <- tumorContour %>% bind_rows %>% dplyr::select(X,Y) %>% as.data.frame

    if(doPlot) {
        flog.debug("plotting")
        plotFOV0(bbData,sampleName,spot,bbPlot,bbFOV0)
        ## plot exclusion boundaries in green
        excB %>% map(dplyr::select,X,Y) %>% map(function(x){lines(x,col=3)})
        ## plot tumor boundaries in brown
        tumorContour %>% map(dplyr::select,X,Y) %>% map(function(p){points(p,pch=15,col="#885555",cex=.5)})
        ## plot cell points in light pink
        points(spCells[ds[["SOX10"]]>0,],col="#FFEEEE",pch=17,cex=.75)
    }

    flog.debug("finding distances closest to boundary")
    ## for each point, find distance to closes boundary point
    dsPt <- ds %>% dplyr::select(X,Y) %>% as.data.frame
    dTumor <- findDistaceFromPointsToInterfacePoint(
        dsPt,
        tumorBoundariesMergeXY
    )
    ## list of true/false indicating whether point is in a tumor
    tumorPoints <- pointsInsidePolygonList(dsPt,tumB)
    ## assign neg to distances for points inside tumor
    dTumor <- ifelse(tumorPoints,-dTumor,dTumor)
    ## convert to um
    dTumor <- dTumor*pixel2um
    ds$Distance <- dTumor
    ds$Band <- cut(dTumor,interfaceBands) ## assign each point to a bin

    return(ds)

}

joinBandArea<-function(bdat,sampleName,spot) {

    #### THESE FILES ARE GENERATED BY computeBoundaryBinsLattice.R
    ## TO DO: GENERATE THESE FILES ON THE FLY???
    bdat$Band=as.character(bdat$Band)
    bandFilePrefix="/home/socci/Work/Users/MellingI/Halo/Infiltration/Version3b/Boundaries/db/BandArea/latticeBandAreaV4ExcClip30_"
    bandAreaFile=paste0(bandFilePrefix,sampleName,"_Spot",spot,"_maxG_6_1.66_.csv")
    bandArea=read_csv(bandAreaFile)
    xx=full_join(bdat,bandArea)
    xx$n[is.na(xx$n)]=0
    xx$Band=factor(xx$Band,levels=bandArea$Band)
    xx %<>% arrange(Band)
    xx

}
