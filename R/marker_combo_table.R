#' Find all marker combinations existing in data and count cells that
#' express each combination and sort combinations by the most to least frequent
#' 
#' Each row contains cell count, percentage and cumulative percentage of all cells,
#' and a column for each marker, with an "X" indicating that marker is part of the
#' combination in that row
#' 
#' @param dataFiles   vector of *.rda files containing Halo data
#' @param markers     vector of individual markers to be counted
#' @param outFile     name of *.xlsx file to write final tables; default=NULL
#' @return list of tables, one for all samples and one for each sample
markerComboCounts <- function(markers, dataFiles=NULL, dat=NULL, outFile=NULL, oneSheet=TRUE){

    allSamps <- tibble()

    cellTypeMarkers <- markers 

    ## get table of "Positive" values for all cell type markers
    ## rows are cells, columns are Sample,UUID,cellTypeMarkers
    if(is.null(dat) && !is.null(dataFiles)){
        for(df in dataFiles){
            dat <- bind_rows(dat, readRDS(df))
            dat$Sample <- gsub("_ObjectAnalysisData","",dat$Sample)
        }
    }
    
    samps <- unique(dat$Sample)

    allSamps <- dat %>%
                filter(Marker %in% cellTypeMarkers) %>%
                mutate(Marker=factor(Marker,levels=cellTypeMarkers)) %>%
                arrange(Marker) %>%
                dplyr::select(Sample,UUID, Marker, Value) %>%
                spread(Marker,Value)

    allTbls <- list()

    ## get counts of each combination of 0's and 1's (representing
    ## a marker combination) & calculate total percentage of all cells
    ## and cumulative percentage
    for(s in c("AllSamples",samps)){

        if(s!="AllSamples"){
            pTbl <- allSamps %>% filter(Sample==s)
            append <- TRUE
        } else {
            pTbl <- allSamps
            append <- FALSE
        }
        cTbl <- pTbl %>% dplyr::select(-(Sample:UUID)) %>%
                group_by_at(vars(one_of(cellTypeMarkers))) %>%
                summarise(Count=n()) %>%
                arrange(desc(Count))
    
        ### these things can't be piped for some reason
        cTbl$PCT <- cTbl$Count/sum(cTbl$Count)
        cTbl$CUM.PCT <- cumsum(cTbl$PCT)

        ### reorder columns 
        cTbl <- cTbl %>% dplyr::select(Count, PCT, CUM.PCT, everything())

        cTbl[,4:ncol(cTbl)][cTbl[,4:ncol(cTbl)] == 0] <- ""
        cTbl[,4:ncol(cTbl)][cTbl[,4:ncol(cTbl)] == 1] <- "X"
 
        allTbls[[s]] <- ungroup(cTbl)
        if("DAPI" %in% names(allTbls[[s]])){
            allTbls[[s]] <- allTbls[[s]] %>% select(-(DAPI))
        }
        if(!is.null(outFile) && !oneSheet){
            write.xlsx(as.data.frame(cTbl), outFile, sheet=s, append=append, row.names=FALSE)
        }
    }
    if(oneSheet){
        tmp <- allTbls[["AllSamples"]]
        combos <- apply(tmp,1,function(x){ return(paste(sort(names(tmp)[which(x=="X")]),collapse=",")) })

        tbl <- tibble(Markers=combos,
                      Cell_Type="",
                      Cell_Subtype="",
                      Total=tmp$Count)
        for(s in samps){
            tmp <- allTbls[[s]]
            combos <- apply(tmp,1,function(x){ return(paste(sort(names(tmp)[which(x=="X")]),collapse=",")) })
            tmp$Markers <- combos
            tmp <- tmp %>% ungroup() %>% select(Markers,Count)
            names(tmp)[ncol(tmp)] <- s
            tbl <- left_join(tbl, tmp, by=c("Markers"))
        }
        tbl[is.na(tbl)] <- 0
        dapiRow <- as.tibble(c(list(Markers="DAPI",Cell_Type="",Cell_Subtype="",Total=sum(tbl$Total)),colSums(tbl[,5:ncol(tbl)])))
        tbl <- bind_rows(tbl, dapiRow) %>% arrange(-Total) 
 
        if(!is.null(outFile)){
            write.xlsx(as.data.frame(tbl), outFile, sheet="AllCounts", append=FALSE, row.names=FALSE)
        }
        return(list("AllCounts"=tbl))
    }

    return(allTbls)
}

#' Interpret marker combinations
#' 
#' Given a file of cell types defined by certain marker combinations (format
#' in docs), assign cell types to each combination in a marker combination counts
#' file
#' 
#' @param markerComboCounts       table generated by markerComboCounts()
#' @param cellTypesFile           *.xlsx file defining cell types based on known marker
#'                                combination (format in docs)
#' @param unreasonableCombosFile  *.xlsx file containing a matrix indicating both known 
#'                                unreasonable pairwise marker combinations and also
#'                                "unknown" pairwise marker combinations
#' @param outFile                 if given, markerComboCounts table with interpretations
#'                                added will be printed to this file
interpretMarkerCombos <- function(markerComboCts, allCellTypes, outFile=NULL){

    cellTypes <- allCellTypes$CellTypes
    conditionalTypes <- allCellTypes$Conditional

    ctCounts <- list()
    cellTypeList <- c()
    cellSubtypeList <- c()
    cellTypeNums <- c()
    comboStrings <- c()
    for(rowNum in 1:nrow(markerComboCts)){
        row <- markerComboCts[rowNum,]
        ctSubCt <- assignCellType(row, cellTypes, conditionalTypes)
        ct <- ctSubCt$cellType
        subct <- ctSubCt$subtype
        if(!ct %in% names(ctCounts)){ 
            ctCounts[[ct]] <- 0
        }
        ctCounts[[ct]] <- ctCounts[[ct]] + 1
        markers <- names(row)[which(row == "X")]
        if(length(markers) == 0){
            comboStr <- ""
        } else if(length(markers) == 1){ 
            comboStr <- paste0(markers, " only") 
        } else {
            comboStr <- paste(markers, collapse = "/")
        }
        cellTypeList <- c(cellTypeList,ct)
        cellSubtypeList <- c(cellSubtypeList, subct)
        cellTypeNums <- c(cellTypeNums, ifelse(ct == "NEGATIVE","",paste0("#",ctCounts[[ct]])))
        comboStrings <- c(comboStrings, comboStr)
    }
    
    ## add a separate column for each piece, to be pasted together later
    markerComboCts$cellType <- cellTypeList
    markerComboCts$subtype <- cellSubtypeList
    markerComboCts$cellTypeNum <- cellTypeNums
    markerComboCts$comboString <- comboStrings
    
    return(markerComboCts)
}

#' Create XLSX workbook and style all sheets for marker combo tables
#'
#' For each marker combo table, create a XLSX sheet and style
#' according to original specifications (TO DO: add options?)
#'
#' @param allTbls  list of tables, one for each sheet, each containing
#'                 the following columns: Count, PCT, CUM.PCT, Interpretation, 
#'                 and a column for each marker being counted
#' @return a completely styled XLSX workbook
markerComboWorkbook <- function(allTbls, cellTypes){

    ## alternating background colors for different cell types
    cellTypeColors <- rep(9,length(cellTypes)) # white
    cellTypeColors[which(1:length(cellTypes) %% 2 == 0)] <- 55 #grey
    
    wb <- createWorkbook(type="xlsx")
    MAIN_STYLE <- CellStyle(wb, border=NULL) + 
                  Alignment(horizontal="ALIGN_CENTER")
    HEADER_STYLE <- MAIN_STYLE + 
                    Font(wb, isBold=TRUE) + 
                    Fill(backgroundColor="#A9A9A9") + 
                    Border(color="black", position="BOTTOM", pen="BORDER_THICK")
    INTERP_STYLE <- MAIN_STYLE + 
                          Font(wb, color="#FF0000", isBold=TRUE)
    INTERP_STYLE_5PCT <- MAIN_STYLE + 
                          Font(wb, color="#6bccf9", isBold=TRUE)
    COUNT_STYLE <- MAIN_STYLE + 
                   Font(wb, color="#FF0000", isBold=TRUE)
    TOTALS_BORDER <- Border(color="black", position=c("BOTTOM"))

    for(t in 1:length(allTbls)){
        s <- names(allTbls)[t]
        tbl <- allTbls[[s]]
        if(grepl("by_cell_type",s)){ s <- gsub("by_cell_type","by_type",s) }
        sheet <- createSheet(wb=wb, sheetName=s)
        interpCol <- which(names(tbl)=="Interpretation") 
        countCol <- which(names(tbl)=="Count")
        totalsRows <- which(is.null(tbl$CUM.PCT)|nchar(tbl$CUM.PCT)==0)
        totalsRows <- totalsRows[-length(totalsRows)]
        columnStyles <- rep(list(MAIN_STYLE), ncol(tbl))
        names(columnStyles) <- 1:ncol(tbl)
        columnStyles[[interpCol]] <- INTERP_STYLE
        columnStyles[[countCol]] <- COUNT_STYLE
        ## add data
        addDataFrame(as.data.frame(tbl), sheet, row.names=FALSE, startRow=1, startColumn=1,
                     colnamesStyle=HEADER_STYLE, colStyle=columnStyles)
        ## fit interpretation column
        autoSizeColumn(sheet, interpCol)

        ## put border around totals columns (really just for sheets that are by cell type)
        for(tr in totalsRows){
            ## add one to row number bc it looks like once in a sheet, the header
            ## is no longer row 1? (or rows are indexed by 0?)
            cb <- CellBlock(sheet, tr+1, 1, 1, ncol(tbl), create=FALSE)
            CB.setBorder(cb, TOTALS_BORDER, 1, 1:ncol(tbl)) 
        }   

        if(grepl("by_cell_type",s)){
            for(x in seq(cellTypes)){
                ctRows <- grep(cellTypes[x],tbl$Interpretation)
                if(length(ctRows) == 0){ next }

                rowIdxs <- c()
                for(r in ctRows){ rowIdxs <- c(rowIdxs,rep(r+1,ncol(tbl))) }

                colIdxs <- rep(1:ncol(tbl), length(ctRows))
                fill <- Fill(backgroundColor=cellTypeColors[x])
                cb <- CellBlock(sheet, ctRows[1]+1, 1, length(ctRows), ncol(tbl), create=FALSE)
                CB.setFill(cb, fill, rowIdxs, colIdxs)
            }
        }
    }

    return(wb)
}

#' Generate XLSX file of all marker combinations represented in
#' given halo data files
#' 
#' XLSX file generated will contain a detailed count sheet and a summary sheet for ALL data, 
#' incluing all samples, and for each sample. Each sheet includes marker count, percentage 
#' and cumulative percentage of all cells that contain each marker combination, and interpretation
#' or cell type of each marker combination
#' 
#' @param dataFiles               vector of *.rda files containing Halo data
#' @param markerFile              file containing a single identity marker on each line     
#' @param cellTypesFile           a *.xlsx file containing sheets for Simple and Complex
#'                                marker combinations that identify certain cell types (format
#'                                described in docs)
#' @param unreasonableCombosFile  a *.xlsx file containing a matrix that indicated invalid or
#'                                "unknown" pairwise combinations of markers in markerFile (format
#'                                described in docs)
#' @param outFile                 name of *.xlsx file to write final tables
#' @export
markerComboXLSX <- function(dataFiles, markerFile, cellTypesFile, unreasonableCombosFile,outFile){
    allCountTbls <- markerComboCounts(dataFiles, markerFile)

    for(x in 1:length(allCountTbls)){
        s <- names(allCountTbls)[x]
        tbl <- allCountTbls[[s]]
        iTbl <- interpretMarkerCombos(tbl, cellTypesFile, unreasonableCombosFile)

        allCountTbls[[s]] <- iTbl %>% 
                unite("Interpretation", cellType, cellTypeNum, comboString, sep = " ") %>%
                dplyr::select(Count, PCT, CUM.PCT, Interpretation, everything())

        totalsByType <- as.tibble(iTbl) %>%
                        filter(CUM.PCT <= 0.95) %>% 
                        group_by(cellType) %>%
                        summarize(Count=sum(Count),PCT=sum(PCT))

        rep_na <- as.list(rep("",ncol(iTbl)))
        names(rep_na) <- names(iTbl)
        allCountTbls[[paste0(s,"_by_cell_type")]] <- iTbl %>% 
                        bind_rows(totalsByType) %>% 
                        replace_na(rep_na) %>%
                        arrange(cellType) %>%
                        unite("Interpretation", cellType, cellTypeNum, comboString, sep = " ") %>%
                        dplyr::select(Count, PCT, CUM.PCT, Interpretation, everything())

    }

    mcWorkbook <- markerComboWorkbook(allCountTbls)

    saveWorkbook(mcWorkbook, "testing_new.xlsx")

    return(allCountTbls)
}
options(stringsAsFactors=FALSE)

#' Shortcut to write a XLSX file 
#' 
#' Write a XLSX file with the following defaults:
#'    row.names = F
#'    append = TRUE
#'    sheetName = NULL
#'
#' @param dat        data to be written, either tibble, matrix or dataframe
#' @param outFile    name of output file
#' @param sheetName  name of Excel Worksheet
#' @param append     logical indicating whether to append to the file or
#'                   overwrite; Default=TRUE
writeXLSXsheet <- function(dat, outFile, sheetName=NULL, append=TRUE){
    write.xlsx(as.data.frame(dat), outFile, row.names=F, sheetName = sheetName, append = append)
}

#' Clean marker file
#' 
#' Remove spaces, new lines, tabs from file
#' 
#' @param markerFile   File condatining list of marker names
#' @param altBases     a vector of alternate markers that will be considered the baseline
#'                     for all other counts
#' @return  a vector of markers
cleanMarkers <- function(markerFile,altBases=NULL){
    markers <- scan(markerFile, "", sep="\n")
    markers <- gsub("[[:space:]]", "", markers)
    if(!is.null(altBases) & length(altBases) > 0){
        for(ab in altBases){
            if(ab != "DAPI"){
                m <- paste0(ab,",DAPI")
                if(! m %in% markers){ 
                    markers <- c(markers,m)
                }
            }
        }
    }
    return(markers)
}

#' Create median row
#' 
#' Given a tibble with the first three columns Sample, FOV, SLICE, 
#' caclulate medians of all remaining columns and return row to be added to tibble
#' 
#' @param  dat    table of counts where first three columns are Sample, 
#'                  FOV, SLICE, and the remaining columns are marker counts or fractions
#' @param  samp   sample name
#' @return   a row where Sample is the unique sample in input table, FOV and SLICE are NA,
#'           and the remaining values are medians of each column
medianRow <- function(dat,samp){
    meds <- as.list(apply(dat[,4:ncol(dat)],2,median))
    medRow <- list(Sample=samp, FOV=NA, SLICE=NA)   
    medRow <- c(medRow, meds)
    return(as.tibble(medRow))
}

computeMultiMarkerTable<-function(mt,markerCols) {
    for(ii in which(grepl(",",markerCols))) {
        markers=strsplit(markerCols[ii],",")[[1]]
        mt[[markerCols[ii]]] = mt %>%
            dplyr::select(one_of(markers)) %>%
            mutate(XX=ifelse(rowSums(.)==len(markers),1,0)) %$%
            as.vector(XX)
    }

    ## Remove any DAPI negative cells
    mt %<>% filter(DAPI==1)
}
