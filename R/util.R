DATE <- function() {gsub("-","",Sys.Date())}

cc <- function(...) {paste(...,sep='_')}

len <- function(x) {length(x)}

tty.width <- function() {
   con=pipe("~/bin/getTTYWidth")
   dat=readLines(con,n=1)
   close(con)
   width=as.numeric(dat)
   if(len(width)>0 && width>80) {
     return(width)
   } else {
     return(80)
   }
}

write.xls <- function(dd,filename,row.names=T,col.names=NA,na="NA",append=F) {
  if (!is.data.frame(dd)) {
    dd <- data.frame(dd,check.names=F)
  }
  if(!row.names) {
    col.names=T
  }
  write.table(dd,file=filename,sep="\t",quote=FALSE,
              col.names=col.names,row.names=row.names,na=na,append=append)
}

getSDIR<-function(){
    args=commandArgs(trailing=F)
    TAG="--file="
    path_idx=grep(TAG,args)
    SDIR=dirname(substr(args[path_idx],nchar(TAG)+1,nchar(args[path_idx])))
    if(len(SDIR)==0) {
        return(getwd())
    } else {
        return(SDIR)
    }
}




#' Extract sample name from file name
#' 
#' Assuming sample name does not include underscores,
#' return everything preceding the first underscore 
#' 
#' @param  filePath  file, which may or may not include full path
getSampleFromFileName <- function(filePath){
  gsub("_.*","",basename(filePath))
}

#' Generate string for selecting markers based on positive
#' or negative value in data
#' 
#' 
markerStringToPredicate<-function(ss) {
    mm=strsplit(ss,",")[[1]]
    mm_neg=gsub("-","",mm[grepl("-$",mm)])
    mm_pos=mm[!grepl("-$",mm)]
    if(len(mm_pos) > 0 & len(mm_neg) > 0) {
        paste(
            paste(mm_pos,"== 1"),
            paste(mm_neg,"== 0"),
            sep=" & ",collapse=" & "
        )
    } else if(len(mm_pos) == 0 & len(mm_neg) > 0){
        paste(mm_neg," == 0", collapse=" & ")
    } else {
        paste(
            paste(mm_pos,"== 1"),
            sep=" & ",collapse=" & "
        )
    }
}

markerStringToSelectRE<-function(ss){
    mm=strsplit(gsub("-","",ss),",")[[1]]
    paste0("(",paste(mm,collapse="|"),")")
}

#' Split data in *.rda file by FOV (SPOT)
#' 
#' Take in *.rda file containing data for multiple
#' FOV and output one *.rda file for each one. Input
#' tibble must have FOV column named "SPOT". Output
#' file will be named "FOV_[$SPOT].rda"
#' 
#' @param dat      input tibble/data.frame
#' @param outDir   output directory
#' @export
splitByFov <- function(dat,outDir){
    for(i in levels(as.factor(dat$SPOT))){
        fname <- file.path(outDir,paste0("FOV_",i))
        fov <- filter(dat, SPOT==i)
        saveRDS(fov, paste0(fname,".rda"))
    }
}

#' Get all possible combinations of markers
#'
#' Given a vector of single markers, return a list
#' of all possible combinations of those markers,
#' including both positive and negative variations
#' 
#' @param markers  vector of single markers
#' @return  list of all combinations
#' @export
getAllCombos <- function(markers){
    all.combos = list()
    ## get all combinations of markers
    for(x in 1:length(markers)){
        ## get all combos of x
        combos = combn(markers,x,simplify=FALSE)
        all.combos = c(all.combos, combos)
    }

    for(c in 1:length(all.combos)){
        combo = all.combos[[c]]
        if(length(combo) < length(markers)){
            all.combos[[c]] <- c(combo,paste0(setdiff(markers,combo),"-"))
        }
        all.combos[[c]] <- paste0(all.combos[[c]],collapse=",")
    }
    return(all.combos)
}


#' Log project parameters
#' 
#' Log all parameters set using either command line arguments
#' or manifest file
#' 
#' @param project_params  list of project parameters and values 
#'                        generated by projectParams()
#' @param action          action being carried out for the project (e.g., 
#'                        "generating counts" or "making pie charts")
#' @export
logParams <- function(project_params,action){
    x <- project_params
    write(date(),file=x$log)
    write(paste0("\n",action," with params:\n"),file=x$log,append=TRUE)
    for(n in names(x)){
        #val <- paste(n," = ",paste(x[[n]],collapse=","))
        if(is.list(x[[n]])){
            #val <- paste(names(x[[n]]), paste(x[[n]],collapse="+"), sep=":")
            tmp <- x[[n]]
            val <- c()
            for(v in names(tmp)){
                val <- c(val, paste(v,paste(tmp[[v]],collapse="+"),sep=":"))
            }
            val <- paste(val, collapse=";;")
        } else {
            val <- paste(x[[n]],collapse=",")
        }
        val <- paste0(n, "\t", val)
        write(val, file=x$log, append=TRUE)
    }
    write("\n#######################################################################\n",file=x$log,append=TRUE)
}

#' Build list of project parameters and values by reading
#' project manifest
#' 
#' Given a tab-delimited file of key-value pairs, read
#' them into list. File may contain comments both on top and in columns
#' beyond the second, but will be ignored here
#'
#' TO DO: Add to description list of required and optional keys in file
#' 
#' @param    file    manifest file to be read
#' @param    type    type of project being run ["counts"|"pie_charts"|"spatial_plots"];
#'                   default="counts"
#' @return   a list of all project parameters
#' @export
initializeProject <- function(file,type="counts"){
    ## set defaults for all projects
    pp <- list( log=NULL, 
                debug=FALSE,
                pad=30,
                exclude_sample_fov=NULL,
                exclude_sample=NULL,
                exclude_fov=NULL,
                exclude_marker=NULL )

    countsPP <- list( markers=NULL,
                      data_dir=NULL,
                      fov=NULL,
                      alt_bases=c(),
                      run_counts=TRUE,
                      run_frac_total=TRUE,
                      run_medians=TRUE,
                      counts_rda_file=NULL,
                      counts_xlsx_file=NULL,
                      write_xlsx_file=TRUE,   
                      save_rds_file=TRUE )

    piePP <- list( pie_charts=TRUE, 
                   counts_rda_file=NULL,
                   custom_colors=FALSE,
                   pdf_pie_charts_by_sample=NULL,
                   other_threshold=0,
                   draw_legend=TRUE,
                   cell_type_markers=NULL )

    spatialPP <- list( data_file=NULL,
                       cell_types_file=NULL,
                       cell_type_name=NULL,
                       annotations_dir=NULL,
                       func_marker=NULL,
                       write_csv_files=TRUE,
                       sample_color=NULL,
                       sample_colors_d=NULL,
                       sort_by_marker="CD3",
                       fov_bb=list(X0=1,X1=5363,Y0=-3343,Y1=1),
                       plot_bb=list(X0=-499,X1=5363,Y0=-3343,Y1=500)
                      )

    if(type == "counts"){
        pp <- c(pp, countsPP)
    } else if(type == "pie_charts"){
        pp <- c(pp, piePP)
    } else if(type == "spatial_plots"){
        pp <- c(pp, spatialPP)
    } else {
        flog.warn("Unrecognized project type '%s'. Not setting ANY defaults. Reading strictly from manifest.",type) 
    }

    ## process manifest
    pp <- tryCatch({
        pp <- read_yaml(file)
        flog.debug("Read YAML file. WARNING: No defaults were set. Relying completely on manifest file for ALL settings.")
        pp
        #warning("No defaults were set. Relying completely on manifest file for ALL settings.")
      }, error = function(e){
        flog.debug("File not in YAML format. Reading manifest in tab-delimited format") 
        #print(e)
        man <- read.delim(file, sep="\t", comment.char="#", header=FALSE, stringsAsFactors=FALSE)[,c(1,2)]
        for(x in 1:nrow(man)){
            if(man[x,2] %in% c("TRUE","FALSE")){
                pp[[man[x,1]]] <- ifelse(man[x,2] == "TRUE",TRUE,FALSE)
            } else if(man[x,2] == "NULL"){
                pp[[man[x,1]]] <- NULL
            } else if(length(grep(";;",man[x,2])) > 0){
                tmp <- parseManifestList(man[x,2])
                for(n in names(tmp)){
                    if(length(grep(",",tmp[[n]])) == 0){
                        tmp[[n]] <- type.convert(tmp[[n]],as.is=TRUE)
                    }
                }
                pp[[man[x,1]]] <- tmp
            } else if(length(grep(",",man[x,2])) > 0){
                tmp <- trimws(unlist(strsplit(man[x,2],",")))
                for(n in 1:length(tmp)){
                    tmp[n] <- type.convert(tmp[n],as.is=TRUE)
                }
                pp[[man[x,1]]] <- trimws(unlist(strsplit(man[x,2],",")))
            } else {
                pp[[man[x,1]]] <- type.convert(man[x,2],as.is=TRUE)
            }
            ## add '#' to hex colors
            if(length(grep("color",man[x,1],ignore.case=TRUE)) > 0){
                if(is.list(pp[[man[x,1]]])){
                    for(n in names(pp[[man[x,1]]])){
                        pp[[man[x,1]]][[n]] <- paste0("#",pp[[man[x,1]]][[n]])
                    }
                } else {
                    pp[[man[x,1]]] <- paste0("#",pp[[man[x,1]]])
                }
            }
        }
        pp
    }, finally = {
        pp
    })

    ## set log file 
    if(is.null(pp$log)){
        if(!is.null(pp$data_dir)){
            df <- file.path(pp$data_dir,dir(pp$data_dir)[grep("\\.rda$",dir(pp$data_dir))]) 
            pp$log <- projectFileName(pp$markers,df,pp$pad,"log")
        } else if(!is.null(pp$data_file)){
            pp$log <- gsub("\\.rda",".log",pp$data_file)
        } else {
            pp$log <- projectFileName(pp$markers,c("_"),pp$pad,"log")
        }
    }

    ## set up logger
    flog.threshold(DEBUG)
    if(!pp$debug){ flog.threshold(INFO) }
    flog.appender(appender.file(pp$log))

    return(pp)
}

#' Remove from counts tibble any FOV to be excluded
#'
#' Filter data to exclude specific FOV for specific samples
#' 
#' @param dat                   counts tibble from countMarkers()
#' @param exclude_sample        comma separated string of samples to exclude completely; i.e., all FOV
#'                              and all markers
#' @param exclude_marker        comma separated string of markers to exclude completely; i.e., all FOV
#'                              in all samples
#' @param exclude_sample_marker a string of exclusions in the form: Sample1:CD3+CD4+TGM2,Sample2:CD20
#' @param exclude_sample_fov    a string of exclusions in the form: Sample1:3+5+9,Sample2:1+16+22
#' @export
removeExclusions <- function(dat, exclude_sample=NULL, exclude_marker=NULL, exclude_sample_marker=NULL,
                                  exclude_sample_fov=NULL){
   
    ## remove specific FOV from specific samples  
    if(!is.null(exclude_sample_fov)){

        ## at some points the data has "SPOT" and at some is has "FOV"
        if("SPOT" %in% names(dat)){
            fovH <- "SPOT" 
        } else if ("FOV" %in% names(dat)){
            fovH <- "FOV"
        } else if(is.null(exclude_sample_fov)){
            flog.fatal("Data does not contain either SPOT or FOV in the header. Can not remove FOV exclusions")
            stop("Data does not contain either SPOT or FOV in the header. Can not remove FOV exclusions")
        }

        for(samp in names(exclude_sample_fov)){
            fovEx <- exclude_sample_fov[[samp]]
            flog.info("Removing samp %s, FOV %s",samp,fovEx)
            dat <- filter(dat, !(Sample == samp & get(fovH) %in% fovEx))
        }

    } else if(!is.null(exclude_sample_marker)){

        warning("\n\nREMOVED ONE OR MORE MARKERS FROM DATA. THIS INCLUDES ANY 
MARKER COMBINATION WITH THAT/THOSE INDIVIDUAL MARKER(S)\n\n")
        for(samp in names(exclude_sample_marker)){
            mEx <- exclude_sample_marker[[samp]] 
            flog.info("WARNING: REMOVED ONE OR MORE MARKERS FROM DATA. THIS INCLUDES ANY MARKER COMBINATION
                 WITH THAT/THOSE INDIVIDUAL MARKER(S)")
            flog.info("Setting count(s) for %s marker %s to NA",samp,mEx)
            for(m in mEx){
                dat[which(dat$Sample == samp),grep(paste0("(^|,)",m,"-*(,|$)"),names(dat))] <- NA
            }
        }

    } else if(!is.null(exclude_sample)){

        flog.info("Removing sample(s) %s from ALL markers",exclude_sample)
        exclude_sample <- trimws(unlist(strsplit(exclude_sample,",")))
        dat <- filter(dat, !Sample %in% exclude_sample)

    } else if(!is.null(exclude_marker)){

        flog.info("Removing marker(s) %s from ALL samples", exclude_marker)
        exclude_marker <- trimws(unlist(strsplit(exclude_marker,",")))
        for(em in exclude_marker){
            dat <- dplyr::select(dat, -grep(paste0("(^|,)",em,"-*(,|$)")))
        }

    }
    return(dat)
}



#' Generate name of output file for marker stats based on 
#' input file names
#' 
#' Use name of marker file and either a single data file name
#' or the directory of data files to generate output file name
#'
#' @param markerFile    File containing list of marker names
#' @param dataFiles     vector of data file(s)
#' @param pad           amount that will be trimmed from FOV
#' @param type          file type ("rda","txt","xlsx"); essentially
#'                      the file extension
#' @return  file name to be used for saving counts
#' @export
projectFileName <- function(markerFile,dataFiles,pad,type){
    if(is.null(markerFile) || is.null(dataFiles)){
        outFile <- paste0("halo_",format(Sys.Date(), format="%Y%m%d"))
    } else if(length(dataFiles)==1) {
        outFile <- paste("markerTable",
            gsub("_MegaTableV2.rda","",basename(dataFiles[1])),
            file_path_sans_ext(basename(markerFile)),sep="_")
        if(pad > 0){
            outFile <- paste0(outFile, "__PAD_",pad)
        }
    } else {
        outFile <- paste("markerTable",
            basename(dirname(dataFiles[1])),
            substr(digest(sort(dataFiles)),1,8),"__",
            file_path_sans_ext(basename(markerFile)),sep="_")
    }
    if(pad > 0){
        outFile <- paste0(outFile,"__PAD_",pad)
    }
    outFile <- paste0(outFile,".",type)
    return(outFile)
}

#' Convert manifest value string to list
#'
#' Lists can be written out in the manifest in the following form:
#'   Name1:val1,Name2:val1+val2,Name3:val1+val2+val3
#' This function parses this string to give the following list:
#'   list(Name1=val1, Name2=c(val1,val2), Name3=c(val1,val2,val3))
#'
#' @param listString    string representing the list to be returned
#' @return list form of the string given
#' @export
parseManifestList <- function(listString){
    manList <- list()
    listElements <- trimws(unlist(strsplit(listString,";;")))
    for(le in listElements){
        tmp <- trimws(unlist(strsplit(le,":")))
        nm <- tmp[1]
        val <- tmp[2]
        if(nm %in% names(manList)){
            flog.fatal("Element %s occurs in list string multiple times. Please correct manifest.",nm)
            stop(paste0("Element ",nm, " occurs in list string multiple times. Please correct manifest."))
        }
        manList[[nm]] <- trimws(unlist(strsplit(val,"\\+")))
    }
    manList    
}
